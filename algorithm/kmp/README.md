# Knuth-Morris-Pratt Algorithm (KMP 알고리즘)

> *문자열중에 특정 패턴을 찾아내는 문자열 검색 알고리즘중 하나*

<br>

## 특징

* 문자열 검색 알고리즘이란, 특정한 글이 있을 때 그 안에서 하나의 문자열을 찾는 알고리즘이다.

* KMP 알고리즘은 **접두사와 접미사의 개념을 활용**하여 '**반복되는 연산을 얼마나 줄일 수 있는 지**'를 판별하여 매칭할 문자열을 빠르게 점프하는 기법

* 실패된 매칭이라도 실패 이전에 매칭되었는 정보를 버리지 않고 다음 매칭을 위해 그 정보를 사용해보자는 것이 핵심 아이디어

* 기존 선형방식은 O(N*M)이지만, KMP 알고리즘은 O(N+M) 시간복잡도를 가진다.

<br>

## 알고리즘 설계 및 구현

### 브루트 포스

* 문자열을 패턴에 맞추고 왼쪽에서 오른쪽으로 문자 비교를 수행합니다.
* 기존 방식인 문자열과 패턴 문자열을 하나하나 비교해보는 방법은 굉장히 **비효율적**입니다.

    |    문자열    |     A      |      B     |     D      |  A  |  B  |  A  |  B  |  C  |  A  |  B  |
    | :----------: | :--------: | :--------: | :--------: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
    |**1번째 비교**|<u>**A**</u>|      B     |     C      |  A  |  B  |     |     |     |     |     |
    |    **2**     |     A      |<u>**B**</u>|     C      |  A  |  B  |     |     |     |     |     |
    |    **3**     |     A      |     B      |<u>**C**</u>|  A  |  B  |     |     |     |     |     |
    |    **4**     |            |<u>**A**</u>|     B      |  C  |  A  |  B  |     |     |     |     |
    |    **5**     |            |            |<u>**A**</u>|  B  |  C  |  A  |  B  |     |     |     |
    |     ...      |            |            |            |     |     |     |     |     |     |     |

<br>

### 개선시키기

* 불일치가 발생할 때 한 문자를 이동시키는 것 보다 <u>지능적인 방법</u>으로 패턴 이동을 하면 기존의 방식을 개선시킬 수 있습니다.

* KMP 알고리즘은 아래처럼 전처리 단계를 통해 패턴 이동이 가능합니다.

|    문자열    |     A      |     B      |  D  |     A      |     B      |     A      |     B      |  C  |  A  |  B  |
| :---------:  | :--------: | :--------: | :-: | :--------: | :--------: | :--------: | :--------: | :-: | :-: | :-: |
|**1번째 비교**|<u>**A**<u/>|<u>**B**<u/>|  C  |     A      |     B      |            |            |     |     |     |
|    **2**     |            |            |     |<u>**A**<u/>|<u>**B**<u/>|     C      |     A      |  B  |     |     |
|    **3**     |            |            |     |            |            |<u>**A**<u/>|<u>**B**<u/>|  C  |  A  |  B  |

<br>

**어떻게 이런 이동이 가능한 지 알아볼까요?**

<br>

### 전처리 단계

* 위와 같이 건너뛰기 위해선 **<u>건너 뛴 후의 패턴 문자열의 앞 부분</u>과 <u>문자열 뒷부분</u>이 동일**해야 함

* 그러기 위해선, 패턴 문자열의 접두사와 접미사를 알아야 합니다.

#### 접두사와 접미사

* ABCAB의 접두사와 접미사는 다음과 같습니다.

##### ABCAB의 접두사

1. A
2. AB
3. ABC
4. ABCA
5. ABCAB

##### ABCAB의 접미사

1. B
2. AB
3. CAB
4. BCAB
5. ABCAB

<br>

### Failure Function, 실패 함수

* 불일치가 발생했을 때, 즉, 실패했을 때 어떻게 해야하는지 알려준다는 점에서 실패 함수(failure function)라 합니다.

* 실패 함수는 KMP알고리즘 실행중, 일치하지 않는 문자가 있을 때 어디서부터 검색을 해야할지(몇칸을 뛰어넘어야 하는지) 알려주는 지표같은 존재

* 실패 함수를 `F(k)`라 하면, 그 의미는 **k번째 인덱스**에서 <u>**접두사와 접미사가 일치하는 최대길이**</u>이다.

* F(0)은 항상 0이다.

1. ABCAB
    | 인덱스 | 문자열 | 접두사 == 접미사 |   F(k)   |
    | :----: | :----: | :--------------: | :------: |
    |   0    | A      |                  | F(0) = 0 |
    |   1    | AB     |                  | F(1) = 0 |
    |   2    | ABC    |                  | F(2) = 0 |
    |   3    | ABCA   |        A         | F(3) = 1 |
    |   4    | ABCAB  |        AB        | F(4) = 2 |

2. AABAA
    | 인덱스 | 문자열 | 접두사 == 접미사 |   F(k)   |
    | :----: | :----: | :--------------: | :------: |
    |   0    | A      |                  | F(0) = 0 |
    |   1    | AA     |        A         | F(1) = 1 |
    |   2    | AAB    |                  | F(2) = 0 |
    |   3    | AABA   |        A         | F(3) = 1 |
    |   4    | AABAA  |        AA        | F(4) = 2 |

3. ABABAB
    | 인덱스 | 문자열 | 접두사 == 접미사 |   F(k)   |
    | :----: | :----: | :--------------: | :------: |
    |   0    | A      |                  | F(0) = 0 |
    |   1    | AB     |                  | F(1) = 0 |
    |   2    | ABA    |        A         | F(2) = 1 |
    |   3    | ABAB   |        AB        | F(3) = 2 |
    |   4    | ABABA  |        ABA       | F(4) = 3 |
    |   5    | ABABAB |        ABAB      | F(5) = 4 |

#### 실패 함수 구현

* **j는 패턴 인덱스이다.**
* **i는 F()에 값을 저장하기 위해 활용하는 인덱스이다.**
* **실패 함수 구현은 5가지만 기억하면 된다.**

1. F(0)은 항상 0이다.
2. j는 0부터, i는 1부터 끝까지
3. `j > 0` && `j != i` -----------> `j = F[j-1]` (여기서는 i 증가 없음!!)
4. `j == 0` && `j != i` ----------> `F[i] = 0` && `i++`
5. `j == i` -----------------------> `F[i] = j+1` && `j++` && `i++`

<!-- |      |  j  |  i  |     |     |     |     |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: |
| 패턴 |<u>**A**<u/>|<u>**B**<u/>|  A  |  B  |  A  |  A  |
| F(k) |  0  |  0  |     |     |     |     |

|      |  j  |     |  i  |     |     |     |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: |
| 패턴 |<u>**A**<u/>|  B |<u>**A**<u/>|  B  |  A  |  A  |
| F(k) |  0  |  0  |  1  |     |     |     |

|      |     |  j  |     |  i  |     |     |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: |
| 패턴 |  A  |<u>**B**<u/>|   A   |<u>**B**<u/>|  A  |  A  |
| F(k) |  0  |  0  |  1  |  2  |     |     |

|      |     |     |  j   |    |  i  |     |
| :--: | :-: | :-: | :-: | :-: | :-: | :-: |
| 패턴 |  A  |<u>**B**<u/>|   A   |<u>**B**<u/>|  A  |  A  |
| F(k) |  0  |  0  |  1  |  2  |     |     | -->

```swift
func makeFailFunc(pattern p: [Character]) -> [Int] {
    var failFunc = [Int](repeating: 0, count: p.count)  // 1. F(0)은 항상 0이니까 0으로 초기화
    var j = 0  // 2. j: 패턴 인덱스, 0부터 시작

    for i in 1..<p.count {  // 2. i: F()값을 저장하기 위해 활용하는 인덱스, 1부터 끝까지
        
        // 3. {j > 0} && {j != i} 이면, {j = F[j-1]}
        while j > 0, p[i] != p[j] {
            j = failFunc[j-1]
        }

        // 5. {j == i}이면, {F[i] = j인덱스 + 1} && {i, j 둘 다 1 증가}
        if p[j] == p[i] {
            j += 1
            failFunc[i] = j
        }

        // 4. {j == 0} && {j != i} 이면, {F[i] = 0} & {i += 1}
    }
    return failFunc
}

// Testcase
print(makeFailFunc(pattern: Array("ABABAB"))) // > [0, 0, 1, 2, 3, 4]
```

<br>

### KMP 알고리즘
> 위에 만든 Failure Function을 활용하여 KMP 알고리즘을 구현해보자

* **i는 문자열의 인덱스이다.**

* **j는 패턴 인덱스이다.**

* **KMP 구현 또한 아래를 기억하면 된다.**

  1. 패턴의 문자와 문자열의 문자와 같은 경우
      1. 패턴 인덱스가 끝까지 간 경우 
          * **패턴 발견!!**
          * j = F[j] `또 다른 패턴을 찾기 위해서`
          * i 증가
      2. 아닌 경우
          * j++
          * i++

  2. 패턴의 문자와 문자열의 문자와 다른 경우

      1. j > 0이면, 
          * j = F[j-1] `여기서는 i 증가 없음!!`

      2. j == 0이면
          * i++

```swift
func kmpSearch(str s: [Character], pattern p: [Character]) -> [Int] {
    var result = [Int]()
    let failFunc = makeFailFunc(pattern: p)
    var j = 0  // j : 패턴 인덱스
    
    // i : 문자열 인덱스
    for i in 0..<s.count {

        // 2-1. {문자가 서로 다름} && {j > 0} 이면, {j = F[j-1]}
        while j > 0, s[i] != p[j] {
            j = failFunc[j - 1]
        }
        
        // 문자가 서로 같으면
        if s[i] == p[j] {
            // 1-1. 패턴 인덱스가 끝까지 갔으면 패턴 발견!
            if j == p.count - 1 {  
                result.append(i - p.count + 2)
                j = failFunc[j]
            } else {  // 1-2. 패턴 끝이 아니면, {i, j 둘 다 증가}
                j += 1
            }
        }

        // 2-2. {문자가 서로 다름} && {j == 0} 이면, {i++}
    }
    return result
}
```

* **while j > 0, s[i] != p[j]** 부분이 이해하기 어렵기 때문에 예시로 보여드리겠습니다.

* 실패함수는 다음과 같습니다.  
    > [0, 0, 1, 2, 3, 4, 5, 6, 0]

1. i, j가 8인 경우부터 시작하겠습니다.

    |    i     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |     8      | 9 | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
    | :------: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:----------:|:-:| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
    |**문자열**| A | B | A | B | A | B | A | B |<u>**B**<u/>| A |  B  |  A  |  B  |  A  |  B  |  A  |  B  |  C  |
    | **패턴** | A | B | A | B | A | B | A | B |<u>**C**<u/>|   |     |     |     |     |     |     |     |     |
    |  **j**   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |     8      |   |     |     |     |     |     |     |     |     |

    B와 C가 일치하지 않아 j = F(j - 1) = F(8 - 1) = F(7) = 6 

    |    i     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |     8      | 9 | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
    | :------: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:----------:|:-:| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
    |**문자열**| A | B | A | B | A | B | A | B |<u>**B**<u/>| A |  B  |  A  |  B  |  A  |  B  |  A  |  B  |  C  |
    | **패턴** |   |   | A | B | A | B | A | B |<u>**A**<u/>| B |  C  |     |     |     |     |     |     |     |
    |  **j**   |   |   | 0 | 1 | 2 | 3 | 4 | 5 |     6      | 7 |  8  |     |     |     |     |     |     |     |

    B와 A가 일치하지 않아 j = F(6 - 1) = F(5) = 4

    |    i     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |     8      | 9 | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
    | :------: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:----------:|:-:| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
    |**문자열**| A | B | A | B | A | B | A | B |<u>**B**<u/>| A |  B  |  A  |  B  |  A  |  B  |  A  |  B  |  C  |
    | **패턴** |   |   |   |   | A | B | A | B |<u>**A**<u/>| B |  A  |  B  |  C  |     |     |     |     |     |
    |  **j**   |   |   |   |   | 0 | 1 | 2 | 3 |     4      | 5 |  6  |  7  |  8  |     |     |     |     |     |

    B와 A가 일치하지 않아 j = F(4 - 1) = F(3) = 2

    |    i     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |     8      | 9 | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
    | :------: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:----------:|:-:| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
    |**문자열**| A | B | A | B | A | B | A | B |<u>**B**<u/>| A |  B  |  A  |  B  |  A  |  B  |  A  |  B  |  C  |
    | **패턴** |   |   |   |   |   |   | A | B |<u>**A**<u/>| B |  A  |  B  |  A  |  B  |  C  |     |     |     |
    |  **j**   |   |   |   |   |   |   | 0 | 1 |     2      | 3 |  4  |  5  |  6  |  7  |  8  |     |     |     |

    B와 A가 일치하지 않아 j = F(2 - 1) = F(1) = 0  
    **j가 0이므로 i 증가**

    |    i     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |     9      | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
    | :------: |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:----------:| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
    |**문자열**| A | B | A | B | A | B | A | B | B |<u>**A**<u/>|  B  |  A  |  B  |  A  |  B  |  A  |  B  |  C  |
    | **패턴** |   |   |   |   |   |   |   |   |   |<u>**A**<u/>|  B  |  A  |  B  |  A  |  B  |  A  |  B  |  C  |
    |  **j**   |   |   |   |   |   |   |   |   |   |     0      |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |

    B와 A가 일치하므로 패턴 끝까지 갈 때까지 i, j 증가

<br>

## 시간 복잡도

**브루트 포스**의 시간 복잡도는 문자열의 길이가 N, 패턴의 길이가 M 일때 **O(NM)** 이다.

반면, **KMP 알고리즘**의 시간 복잡도는 **O(N + M)** 이다.


<br>

## 전체 코드

### Swift
[전체 코드](./src/kmpSearch.swift)

```swift
func kmpSearch(str s: [Character], pattern p: [Character]) -> [Int] {
    var result = [Int]()
    let failFunc = makeFailFunc(pattern: p)
    var j = 0  // j : 패턴 인덱스
    
    // i : 문자열 인덱스
    for i in 0..<s.count {

        // {문자가 서로 다름} && {j > 0} 이면, {j = F[j-1]}
        while j > 0, s[i] != p[j] {
            j = failFunc[j - 1]
        }
        
        // 문자가 서로 같으면
        if s[i] == p[j] {
            // 패턴 인덱스가 끝까지 갔으면 패턴 발견!
            if j == p.count - 1 {  
                result.append(i - p.count + 1)  // 문자열에서 패턴 시작 인덱스 저장
                j = failFunc[j]
            } else {  // 패턴 끝이 아니면, {i, j 둘 다 증가}
                j += 1
            }
        }

        // {문자가 서로 다름} && {j == 0} 이면, {i++}
    }
    return result
}

func makeFailFunc(pattern p: [Character]) -> [Int] {
    var failFunc = [Int](repeating: 0, count: p.count)  // F(0)은 항상 0이니까 0으로 초기화
    var j = 0  // j: 패턴 인덱스, 0부터 시작

    for i in 1..<p.count {  // i: F()값을 저장하기 위해 활용하는 인덱스, 1부터 끝까지

        // {j > 0} && {j != i} 이면, {j = F[j-1]}
        while j > 0, p[i] != p[j] {
            j = failFunc[j-1]
        }

        // {j == i}이면, {F[i] = j인덱스 + 1} && {i, j 둘 다 1 증가}
        if p[j] == p[i] {
            j += 1
            failFunc[i] = j
        }

        // {j == 0} && {j != i} 이면, {F[i] = 0} & {i += 1}
    }
    return failFunc
}

// Testcase
let text = "ABDABABCAB"
let pattern = "ABCAB"

print(kmpSearch(str: Array(text), pattern: Array(pattern)))  // > [5]
```
---